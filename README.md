---
title: A minimalist workflow structure for Snakemake
---

I have [heard of][karl] the use of [GNU Make][[make] for enhancing
reproducibility for some time. I did not incorporate Make into my work, however,
since a simple build script written in Bash was sufficient. Everything was well
in control, and I could structure the workflow to my will.

It was not until I started working in a company setting that I found most things
out of my control. Decades of conventions have been accumulating and passing on,
and personal workflows have to fit into existing ones. In order to fit into my
company's conventions of data analysis (which pretty much just ignore analysis
reproducibility), the number of scripts grew exponentially and quickly fell out
of my control (see figure below). I needed a way to document and track my
workflow in a consistent and scalable manner. This was when I picked up Prof.
Broman's [great introductory post][karl] on GNU Make again. Then, I was defeated
by the omnipresent Windows. Since I have to work on Windows machines in the
company, and since [Make for Windows][makeforwin] has difficulties dealing with
Chinese file paths, I had to give up on Make. [Snakemake][snk] then came as my
savior. 

![Data analysis workflow graph generated by Snakemake](https://img.yongfu.name/posts/dag.png)


## Meeting Snakemake

Snakemake was inspired by, but way more complicated than, GNU Make. Since it is
backed by Python, cross-platform issues such as character encodings are
automatically resolved. Snakemake was developed to facilitate computational
research and reproducibility. It may take some time to get started with
Snakemake, but it's totally worth it. Dealing with complex tasks requires a
complicated framework. But often, these complications make sense (and are
appreciated) only after we face real-world complex tasks. Going through
[Snakemake's tutorial][tutor] and experimenting with it on the computer would be
sufficient to get an average user started. It is not as complicated as it seems
at first glance. 


## Snakemake Recommended Workflow

A great thing about Snakemake is that it is opinionated. This means that certain
conventions[^convention] are proposed, and most users would benefit from these
conventions since the burden of structuring the workflow is spared.

For instance, Snakemake [recommends][snk-flow] the directory structure listed
below for every Snakemake workflow. This structure is so simple such that it
might not be easy to appreciate its genius at first glance. There are four
directories---`workflow`, `config`, `results`, and `resources`---in the project
root. `workflow` holds the "coding" stuff. Code for data analysis, computation,
and reproducibility can all be found in this directory. `config` is for optional
configuration and I would skip it here (in my own project, I did not use
`config` files since the `Snakefile` is sufficient for my purposes). `results`
and `resources` are what (I think) make this structure fantastic. `resources`
holds all **raw data**, i.e., data that are not reproducible on your computer
(e.g., manually annotated data). All data resulting from the computation in the
current project are located in `results`. So ideally, you can delete `results`
at any time without worries since a single command `snakmake -c` would generate
all the results from `resources`. The genius of this structure is that it
eliminates the need of worrying about where to place newly arrived data, as
commonly encountered in real-world situations (e.g., an analysis might require
data that you did not foresee).

```
├── .gitignore
├── README.md
├── LICENSE.md
├── workflow
│   ├── rules
|   │   ├── module1.smk
|   │   └── module2.smk
│   ├── scripts
|   │   ├── script1.py
|   │   └── script2.R
|   └── Snakefile
├── config
│   └── config.yaml
├── results
└── resources
```

## An Enhanced Snakemake Workflow

I adopted the workflow above in my work. It was great, but I still find **two
annoying drawbacks**. 

First, the lengths of the four directories' names are too
long. Since in a `Snakefile`, file paths of inputs and outputs are always
repeated, it soon becomes annoying to type in paths starting with
`resources/...` and `results/...`. In addition, "resources" and "results" have a
common prefix, which often confuses me. It would be better if the two terms
could more readily be visually distinguished. 

Second, the recommended structure of Snakemake results in confusing relative
paths. According to the [documentation][snk-rel-path], relative paths in
different directives are **interpreted differently**.  To be short, relative
paths in `input:`/`output:`/`shell:` are interpreted relative to the working
directory, whereas in directives such as `script:`, they are interpreted as
relative to the `Snakefile`. So it would be cognitively demanding to switch the
reference points of relative paths while writing the `Snakefile`. Why not have
all paths relative to the project root?

To deal with the aforementioned problems, I modified the recommended directory
structure and arrived at the structure below:

```
|-- README.md
|-- Snakefile
|-- made
|-- raw
`-- src
```


[^convention]: "Good" conventions here, as opposed to naturally-resulting 
conventions without the consideration of reproducibility.

[karl]: https://kbroman.org/minimal_make
[makeforwin]: http://gnuwin32.sourceforge.net/packages/make.htm
[make]: https://www.gnu.org/software/make/
[snk]: https://snakemake.github.io
[tutor]: https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html
[snk-flow]: https://snakemake.readthedocs.io/en/stable/snakefiles/deployment.html#distribution-and-reproducibility
[snk-rel-path]: https://snakemake.readthedocs.io/en/latest/project_info/faq.html#how-does-snakemake-interpret-relative-paths

